% !TEX TS-program = xelatex
\documentclass[a4paper, 12pt]{article}
\usepackage[margin=0.8in]{geometry}
\usepackage{tikz}
\usepackage{scrextend}
\usetikzlibrary{automata,positioning}
\usepackage{graphicx}


\lstdefinestyle{customc}{
  frame=leftline,
  framesep=10pt,
  xleftmargin=30pt,
  language=Java,
  basicstyle=\scriptsize\ttfamily,
  tabsize =4,
}

\lstset{escapechar=@,style=customc}

\title{Scotland Yard}
\author{Julian Loscombe and Ben Milne}

\begin{document}
\maketitle
\section{Transitional Issues}
The update to the project files part-way through the project caused a significant lag (-10s) when starting a new game. We tracked this down to the Page Rank algorithm, specifically the iterate() method which is called 100 times at the beginning of a game. In order to see clearly where the problem was we used the System.nanoTime() method to find the time each line of the method took.\\
\includegraphics[width = 8cm]{iterate}
\includegraphics[width = 8cm]{sumPageRanks}\\
\\
Clearly then, the issue is with the getEdges() method in the Graph file. We believe this is because of the change from using Lists to Sets. The cost of iterating over a Set, it seems, is far greater than doing the same for a List as illustrated at http://javacodegeeks.com/2010/08/java-best-practices-vector-arraylist.html.\\
\\
To fix this we created a map on itilialisation which maps a node number to its edges. This means we only need to iterate over the Set once and the result is a significant speed increase.\\
\includegraphics[width = 14cm]{comparison}
\section{Project Schematic}
\includegraphics[width = 17cm]{mvp_schematic}\\
As our project grew it became important to organise our code. To achieve this we came up with the above project structure. You can clearly see the separation of the model and the views.
\section{Animations}
In the first part of the project we did not have sufficient time to add animations to the game. We feel these are important as they guide your attention and allow you to keep track of what is happening more easily. In order to easily implement our animations in this part we created a class called AnimatablePanel which is documented separately.
\section{Benefits of our GUI}
We decided early on to use our own GUI, this is because we feel our GUI has four main advantages over the one provided. Our GUI:
\begin{enumerate}
	\item Automatically make a random move when the time to take a move runs out. Therefore the game will not quit if you take too long.
	\item Allows panning and zooming which especially useful for low resolution screens. The provided GUI does not resize and hence on some screens a potion of the board is cut off and unreachable.
	\item Shows the suggested routes generated by the AI and all the valid moves you can take.
	\item Shows the time remaining for you to make a move clearly, we found the timer on the provided guy was often off screen and impossible to see.
\end{enumerate}
\section{Disadvantages of our GUI}
Although we are generally very pleased with our GUI, we have found some limitations of it:
\begin{enumerate}
	\item It is difficult to see what moves Mr X has previously made as we have used a chat view to communicate game events. In hindsight this is not the best method and the provided GUI is much better for this. We decided to use this method before we knew the limitations of the networking, hoping to enable client to client chat.
	\item It is very difficult to see what tickets other players are holding. Again we hoped to mitigate this issue using the chat.
\end{enumerate}
\section{The horrible bug with the networking}
When connecting our GUI to the networking part of the project, we encountered a difficult to trace bug, as you may remember. The problem was that the PlayerClient class calls model.start() in the run() method, but we also called model.start() on another thread as we did not know that it had already been done. This meant that the game was effectively started twice on two Threads causing havoc with the updating of our GUI. To solve this problem we changed our code so only the PlayerClient called the model.start() method. It would have been helpful to either add the synchronised tag to the model.start() method or add some documentation about the PlayerClient class.
\section{The second horrible bug with the networking}
We would often find when running our AI that the server would end the game before we had a chance to make our first move (i.e before 15 seconds after entering the notify function). We performed the below test to ensure it was not an issue with our GUI but with the server itself.
\begin{lstlisting}
private class CustomPanel extends AnimatablePanel {
	AnimatablePanel.Animator radiusAnimator;
	
	public void growCircle() {
		//Create a new Animator with specified values
		radiusAnimator = createAnimator(0.0, 20.0, 0.5);
	}
	
	...
	
	public void paintComponent(Graphics g0) {
		Double r;
		...
		//Draw using the animated value
		if (radiusAnimator != null) r = radiusAnimator.value();
		g.fillOval(x - r, y - r, r * 2, r * 2);
	}
}
\end{lstlisting}
It turned out that  We spend quite a bit of time trying to figure out what we were doing 
\section{Documentation}
We have fully commented our code to the JavaDoc specifications and have generated the html, you can find it in the docs/Documentation/JavaDocs folder.
\end{document}